#!/usr/bin/env perl6
#
# lvst - pretende reemplazar al conjunto de scripts anteriores
#        lvst.pl6, venganzas-del-pasado.pl6, lvst-copiar-mp3.pl6
#        lvst-consultar-programa.pl6.
#

use v6;


my $ogg = "$*HOME/Música/lvst";
my $mp3 = "$*HOME/Descargas/torrents";


class Audio {
    has Str $.nombre;
    has IO::Path $.ubicación;
    has Str $.extensión;
    has Date $.fecha;
    has Str $.año;
    has Str $.mes;
    has Str $.día;
    has Int $.tamaño;
}


class Programas {
   has Audio @.programas;
   has Date @.pendientes;

   method buscar-audios ($buscar-en) {
       my @directorios = $buscar-en.IO;
       while @directorios { 
           for @directorios.pop.dir -> $audio {
               if $audio ~~  / ['.mp3' || '.ogg'] $/ {
                  my Str $nombre          = $audio.basename;
                  my Str $extensión       = $audio.extension;
                  my IO::Path $directorio = $audio.dirname.IO;
                  my (Date $fecha, Str $año, Str $mes, Str $día) = 
                    Date.new(~$<fecha>), ~$<fecha><año>, 
                    ~$<fecha><mes>, ~$<fecha><día>
                    if $nombre ~~ /
                      [ 'dolina_' \d**4 '_'  ||  'lavenganza_' ]
                      $<fecha> = ( 
                        $<año> = ( \d**4 ) '-'
                        $<mes> = ( \d**2 ) '-'
                        $<día> = ( \d**2 )
                      )
                      [        '_' \d+       ]?
                      [   '.ogg' || '.mp3'   ]
                    /;
                  my Int $tamaño    = $audio.IO.s; 
                  my Str $metadatos = ''; 

                  @!programas.push: Audio.new(
                      :nombre($nombre),
                      :ubicación($directorio),
                      :extensión($extensión),
                      :fecha($fecha),
                      :año($año),
                      :mes($mes),
                      :día($día),
                      :tamaño($tamaño),
                  );
               }
               @directorios.push: $audio if $audio.d;
           }
       }
   }

   method último-programa () {
       # el último programa disponible

       my Audio @oggs = grep { .extensión eq 'ogg' }, @!programas;
       return @oggs>>.fecha.sort.tail;
   }

   method del-pasado (Date $desde! is copy, Date $hasta! is copy, Bool :$sin-filtro) {
       # genera un rango de fechas

       my Date %rango;
       if $desde lt $hasta {
           until $desde eq $hasta {
               unless $desde.day-of-week == 6|7 { # sábado y domingo no hay programa
                   %rango.push: $desde => $desde;
               }
               $desde .= later(:1day);
           }
       }

       map { %rango{$_}:delete }, @!programas>>.fecha unless $sin-filtro;
       @!pendientes.append: %rango.values.sort;
   }

   method descargar (Bool :$descarga-directa, Bool :$simular) {
       # descarga los programas pendientes

       for @!pendientes -> Date $fecha {
           my Str $url     = 'http://s3.schwindt.org/dolina/';
           my Str $archivo = 'lavenganza_' ~ $fecha ~ '.mp3?torrent'; 

           if $descarga-directa {
               $url = 'https://venganzasdelpasado.com.ar/';
               $archivo = 'lavenganza_' ~ $fecha ~ '.mp3';
           }

           my $url-completa = $url ~ $fecha.year ~ '/' ~ $archivo;

           $simular
               ?? say "simulando: $url-completa"
               !! shell "echo wget $url-completa";
       }
   }

   method mp3-a-ogg () { 
       # convierte, renombra y copia los mp3

       my Audio @mp3 = grep { .extensión eq 'mp3' }, @!programas;
       my Audio @ogg = grep { .extensión eq 'ogg' }, @!programas;

       my Audio %mp3 = map { .fecha => $_ }, @mp3;
       my Int   %ogg = map { .fecha => 1  }, @ogg;

       map { %mp3{$_}:delete if %ogg{$_}:exists }, %mp3.keys.sort;

       for %mp3.values -> $audio {
           my $origen  = $audio.ubicación ~ '/' ~ $audio.nombre; 
           my $nombre  = $audio.nombre.subst('dolina_' ~ $audio.año ~ '_', '')\
                         .subst($audio.extensión, 'ogg');
           my $destino = $ogg ~ '/' ~  $audio.año;

           mkdir $destino unless $destino.IO.d;
           $destino ~= '/' ~ $nombre;

           my @trabajos;
           unless $destino.IO.f {
               my $proc = Proc::Async.new('mp3-a-ogg.sh', $origen, $destino); 
               push @trabajos, $proc.start;

               if @trabajos == 3 {
                   await Promise.anyof(@trabajos);
                   @trabajos .= grep({ !$_ });
               }
           }

           await @trabajos;
       }
   }
}


multi sub MAIN (Bool :$nono) {
    if $ogg.IO.d && $mp3.IO.d {
        my $venganzas = Programas.new;

        $venganzas.buscar-audios($ogg);
        $venganzas.buscar-audios($mp3);

        $venganzas.mp3-a-ogg unless $nono;

        my $último = $venganzas.último-programa;
        my $hoy    = Date.today;

        $venganzas.del-pasado($último, $hoy);

        $nono
            ?? $venganzas.descargar(:simular)
            !! $venganzas.descargar;

    } else {
        note "$mp3 ¡NO ES UN DIRECTORIO!";
        note "$ogg ¡NO ES UN DIRECTORIO!";
        exit 1;
    }
}


multi sub MAIN (
        $desde-fecha,
        $hasta-fecha,
        Bool :$no-filtrar,
        Bool :$descarga-directa,
        Bool :$nono
    ) {

    my $desde = Date.new($desde-fecha); 
    my $hasta = Date.new($hasta-fecha);

    my $venganzas = Programas.new; 

    $venganzas.buscar-audios($ogg);
    $venganzas.buscar-audios($mp3);

    $no-filtrar 
        ?? $venganzas.del-pasado($desde, $hasta, :sin-filtro)
        !! $venganzas.del-pasado($desde, $hasta);

    if $nono {
        $descarga-directa
            ?? $venganzas.descargar(:simular, :descarga-directa)
            !! $venganzas.descargar(:simular);
    } else {
        $descarga-directa
            ?? $venganzas.descargar(:descarga-directa)
            !! $venganzas.descargar;
    }
}
